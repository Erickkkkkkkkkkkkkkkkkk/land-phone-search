## 일반 지침

- 모든 코드는 TypeScript로 작성하며, 엄격한 타입 체크를 사용합니다.
- 코드 재사용성을 극대화하기 위해 모듈화와 컴포넌트 기반 아키텍처를 채택합니다.
- DRY (Don't Repeat Yourself) 원칙을 준수하여 중복을 최소화합니다.
- 명확하고 설명적인 변수명과 함수명을 사용합니다.
- AI 도구를 활용하여 코드 생성 및 버그 수정 작업을 자동화합니다.
- 서버리스 아키텍처를 채택하여 인프라 관리 부담을 줄이고 개발 프로세스를 단순화합니다.
- 마이크로서비스 아키텍처를 사용하여 애플리케이션을 모듈화하고 확장성을 높입니다.
- 사이버 보안을 핵심 요소로 고려하여 설계 단계부터 보안 기능을 통합합니다.
- 5G 기술을 활용한 개발을 고려하여 실시간 경험과 초고속 연결성을 제공합니다.

## Next.js 프론트엔드

### 프로젝트 구조

- `src` 디렉토리를 사용하여 애플리케이션 코드와 설정 파일을 분리합니다.
- App Router를 사용하여 `app` 디렉토리 내에서 라우팅 구조를 정의합니다.
- 공통 컴포넌트는 `src/components`에, 유틸리티 함수는 `src/utils`에, 외부 라이브러리 통합은 `src/lib`에 위치시킵니다.
- 기능이나 라우트별로 관련 파일들을 그룹화하여 모듈성을 높입니다.

### 컴포넌트 구조

- 함수형 컴포넌트와 React Hooks를 사용합니다.
- 컴포넌트 파일 내부 구조:
  1. 임포트
  2. 타입 정의 (Props)
  3. 컴포넌트 정의
  4. Hooks
  5. 이벤트 핸들러 및 메서드
  6. 렌더링 로직 (JSX)

### 네이밍 규칙

- 컴포넌트: PascalCase (예: UserProfile)
- 파일: 컴포넌트는 PascalCase, 일반 파일은 kebab-case
- 폴더: kebab-case
- props와 메서드: camelCase
- 불리언 값: 'is', 'has', 'should' 접두사 사용

### 스타일링

- Tailwind CSS를 사용하여 유틸리티 클래스 기반의 스타일링을 적용합니다.
- CSS 모듈이나 CSS-in-JS 솔루션을 사용하여 스코프된 스타일을 만듭니다.

### 상태 관리

- 로컬 상태는 React Hooks (useState, useReducer)를 사용합니다.
- 글로벌 상태 관리에는 Zustand를 사용합니다.

### 성능 최적화

- React.memo, useMemo, useCallback을 적절히 사용하여 불필요한 리렌더링을 방지합니다.
- 이미지와 자산을 최적화하여 로딩 시간을 단축합니다.
- 코드 분할과 지연 로딩을 구현하여 초기 로드 시간을 개선합니다.

### TypeScript 활용

- `any` 타입 사용을 피하고, props와 상태에 대해 명시적으로 타입을 정의합니다.
- 인터페이스를 사용하여 구조화된 데이터를 표현합니다.

### 테스트

- Jest를 사용한 단위 테스트와 React Testing Library를 활용한 컴포넌트 테스트를 작성합니다.

### 에러 처리

- 에러 바운더리를 사용하여 클라이언트 측 에러를 우아하게 처리합니다.
- 커스텀 404 및 500 페이지를 만들어 사용자 경험을 개선합니다.

## UI 및 스타일링

- UI 컴포넌트는 shadcn을 사용하여 구현합니다. 일관된 디자인 시스템을 유지하세요.
- CSS는 Tailwind CSS를 사용하여 작성합니다. 유틸리티 클래스를 최대한 활용하세요.
- 커스텀 컴포넌트를 만들 때는 shadcn의 디자인 원칙을 따르고 Tailwind CSS로 스타일링합니다.
- 재사용 가능한 UI 컴포넌트를 만들어 공통 디자인 패턴을 구현하세요.
- 반응형 디자인을 위해 Tailwind CSS의 브레이크포인트를 활용합니다.

## Tailwind CSS 클래스 네이밍 규칙

- 의미론적 클래스명을 사용합니다. 예: 'btn-primary' 대신 'button-submit'
- BEM과 유사한 명명 규칙을 따릅니다. 예: 'card__title--large'
- 반응형 접미사를 활용합니다. 예: 'md:flex lg:grid'
- 약어 사용을 자제하고 완전한 단어를 사용합니다. 예: 'nav' 대신 'navigation'
- 유틸리티 클래스에는 'u-' 접두사를 사용합니다. 예: 'u-flex u-items-center'
- 프로젝트의 전체적인 맥락을 고려한 이름을 사용합니다.
- 접근성을 고려한 명확하고 포괄적인 이름을 사용합니다.
- 커스텀 클래스를 만들 때는 'components' 레이어를 활용합니다.
- 클래스 이름은 항상 소문자와 하이픈을 사용하여 작성합니다.
- 상태를 나타내는 클래스는 'is-' 또는 'has-' 접두사를 사용합니다. 예: 'is-active', 'has-error'

## 필수 패키지

- NestJS: @nestjs/common, @nestjs/core, @nestjs/platform-express
- React & Next.js: react, react-dom, next
- 데이터베이스: @prisma/client, @nestjs/typeorm
- 상태 관리: zustand
- UI: @shadcn/ui
- 스타일링: tailwindcss, postcss, autoprefixer
- HTTP 클라이언트: axios
- 유틸리티: lodash
- 날짜 및 시간 처리: luxon
- 테스트: jest, @testing-library/react
- 린팅 및 포맷팅: eslint, prettier
- 에러 처리: nextjs-centralized-error-handler

## 코드 재사용성

- 공통 로직은 커스텀 훅으로 추출하여 여러 컴포넌트에서 재사용합니다.
- 유틸리티 함수를 만들어 반복되는 작업을 모듈화합니다.
- 고차 컴포넌트(HOC)를 사용하여 크로스커팅 관심사를 처리합니다.
- 컴포넌트 합성을 활용하여 유연하고 재사용 가능한 UI를 구축합니다.
- 타입과 인터페이스를 별도의 파일로 분리하여 여러 모듈에서 공유합니다.
- 상수와 설정값을 중앙화하여 관리하고 재사용합니다.

## 성능 최적화

- 이미지와 자산을 최적화하여 로딩 시간을 단축합니다.
- 코드 분할과 지연 로딩을 구현하여 초기 로드 시간을 개선합니다.


이 지침을 따라 코드를 작성하고 제안해 주세요. 항상 재사용성, 확장성, 유지보수성을 고려하여 코드를 설계하세요.

